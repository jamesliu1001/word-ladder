'''
An unweighted, undirected Graph class based on an adjaceny list model.
'''
class Graph:
  def __init__(self, adjacency_list: dict[str, set[str]]):
    '''The Graph class constructor.
    Inititalizes the following data attributes:
    - self.__adjacency_list (dict[str, st[str]]): An adjaceny list model of our Graph
    - self.__vertices (set[str]): A set of all the vertices in the graph
    - self.__edges (set[tuple[str]]]): A set of tuples representing all the edges in the graph 

    Args:
    adjacency_list (dict[str, set[str]]): An adjaceny list model of our Graph
    '''
    ### BEGIN SOLUTION
    self.__adjacency_list = adjacency_list
    self.__vertices = set(adjacency_list.keys())
    self.__edges = set()


    for vertices in adjacency_list:
      for vertex in adjacency_list[vertices]:
        self.__edges.add(tuple(sorted([vertices, vertex])))
                      
    ### END SOLUTION
  
  @property
  def vertices(self):
    '''Accessor method for the vertices attribute'''
    return self.__vertices

  @property
  def edges(self):
    '''Accessor method for the edges attribute'''
    return self.__edges
    
  def is_vertex(self, vertex:str) -> bool:
    '''Determines whether a vertex is present on the graph'''
    ### BEGIN SOLUTION

    return vertex.lower() in self.__vertices

    ### END SOLUTION

  def get_neighbors(self, vertex:str) -> set[str]:
    '''Accessor method for the neighbors of an edge

    Args:
    vertex (str): The given vertex

    Returns:
    set[str] : A set of strings representing all the neighbors of the vertex
    '''
    ### BEGIN SOLUTION
    if vertex not in self.__adjacency_list:
      return set()


    return set(self.__adjacency_list[vertex])

    ### END SOLUTION
    
  def is_valid_path(self, path:tuple[str]) -> bool:
    ''' Determines whether a given path is a valid path on the graph

    Args:
    path (tuple[str]): A list of path vertices

    Returns:
    bool - True if the given path is a valid path on the Graph, otherwise False
    '''
    ### BEGIN SOLUTION
    if len(path) < 2 or len(self.__adjacency_list) == 0:
      return False
    path = list(path)

    for num in range(len(path)):
      if path[num].isalpha(): 
        path[num] = path[num].upper()

    for index in range(len(path)-1): 
      if not self.is_vertex(path[index]) or self.is_vertex(path[index+1]):
        return False
      if path[index+1] in self.__adjacency_list[path[index]]:
        continue
      else: 
        return False
    return True


      
         
      ### END SOLUTION

  def get_shortest_bfs_path(self, start:str, target:str) -> tuple[str]:
    ''' Finds a shortest paths connecting the start vertex with the target vertex.

    Args:
    start: the starting vertex in the path
    target: the last vertex in the path

    Returns:
    tuple[str] - a tuple of str vertices representing a shortest path from start node to target node
    '''
    path_queue = [[start]]

    while path_queue:
      old_path = path_queue.pop(0)
      last_node = old_path[-1]

      for neighbour in self.get_neighbors(last_node):
        if neighbour not in old_path:
          new_path = old_path.copy()
          new_path.append(neighbour)
          path_queue.append(new_path)

        if neighbour == target:
          return tuple(new_path)

    return tuple() #no path exists

  def get_shortest_bfs_path_length(self, start:str, target:str) -> int:
    ''' Finds the number of edges in the shortest path generated by bfs connecting
    the start vertex with the target vertex.

    Args:
    start: the starting vertex in the path
    target: the last vertex in the path

    Returns:
    int - the number of edges traversed to get from source to target in the shortest bfs path
    invalid paths result in a path length of 0
    '''
    ### BEGIN SOLUTION
    if len(self.get_shortest_bfs_path(start, target)) - 1 == -1:
      return 0

    return len(self.get_shortest_bfs_path(start, target)) - 1 

    ### END SOLUTION

  def get_all_shortest_bfs_paths(self, source:str, target:str) -> set[tuple[str]]:
    ''' Finds all of the shortests paths connecting the start vertex with the target vertex.

    Args:
    start: the starting vertex in the path
    target: the last vertex in the path

    Returns:
    set[tuple[str]] - a set of tuples of str vertivces representing all of the shortest paths
    from start node to target node
    '''
    ### BEGIN SOLUTION

    path_queue = [[source]]
    shortest = 2**23
    pathList = []

    # once shortest is found and list moves on to two longer kill soon 
    pathCounter = 2**40
    while path_queue:
      old_path = path_queue.pop(0)
      last_node = old_path[-1]

      if len(old_path) >= pathCounter:
        break
      for neighbour in self.get_neighbors(last_node):

        if neighbour not in old_path:
          new_path = old_path.copy()
          new_path.append(neighbour)
          path_queue.append(new_path)

        if neighbour == target and len(new_path) == shortest:
          pathList.append(tuple(new_path))
          pathCounter = len(new_path)

        elif neighbour == target and len(new_path) < shortest:
          shortest = len(new_path)
          pathList = [tuple(new_path)]
          pathCounter = len(new_path)

    return set(pathList)

### END SOLUTION

if __name__ == "__main__":
  binary_tree_graph ={
       'A':{'B'},
       'B':{'F','A','D'},
       'C':{'D'},
       'D':{'B','C','E'},
       'E':{'D'},
       'F':{'B', 'G'},
       'G':{'F','I'},
       'H':{'I'},
       'I':{'G', 'H'}
    }
  myGraph = Graph(binary_tree_graph)
  print("Vertices:", myGraph.vertices)
  print("Edges:", myGraph.edges)  
  vertex = "F"
  print(f"Neighbers ({vertex}):", myGraph.get_neighbors(vertex))
  good_path=["F", "B", "D", "C"]
  bad_path=["F", "B", "D", "I"]
  print(f"Valid Path {good_path}:", myGraph.is_valid_path(good_path))
  print(f"Invalid Path {bad_path}:", myGraph.is_valid_path(bad_path))
  start = "H"
  target= "C"
  print(f"Shortest Path from {start} to {target}:", myGraph.get_shortest_bfs_path(start, target))
  print(f"Shortest Path Length from {start} to {target}:", myGraph.get_shortest_bfs_path_length(start, target))

  print("--------------------------")
  small_dictionary={
       "foul":{"fool", "foil"},
       "fool":{"foul", "foil", "cool", "pool"},
       "cool":{"fool", "pool"},
       "pool":{"fool", "poll"},
       "poll":{"pool", "pall", "pole"},
       "pole":{"poll", "pale", "pope"},
       "pope":{"pole"},
       "pale":{"pole","pall","page","sale"},
       "sale":{"pale","sage"},
       "sage":{"sale","page"},
       "page":{"pale", "sage"},
       "pall":{"poll", "pale", "fall"},
       "fall":{"fail","pall"},
       "fail":{"fall","foil"},
       "foil":{"foul", "fail"}
     }
  myGraph2 = Graph(small_dictionary)
  print("Vertices:", myGraph2.vertices)
  print("Edges:", myGraph2.edges)  
  vertex = "foil"
  print(f"Neighbers ({vertex}):", myGraph2.get_neighbors(vertex))
  good_path=["pope", "pole", "pale", "page"]
  bad_path=["F", "B", "D", "I"]
  print(f"Valid Path {good_path}:", myGraph2.is_valid_path(good_path))
  print(f"Invalid Path {bad_path}:", myGraph2.is_valid_path(bad_path))
  start = "fool"
  target= "sage"
  print(f"Shortest Path from {start} to {target}:", myGraph2.get_shortest_bfs_path(start, target))
  print(f"Shortest Path Length from {start} to {target}:", myGraph2.get_shortest_bfs_path_length(start, target))
  print("------")
  print(f"All Shortest Path Length from {start} to {target}:", myGraph2.get_all_shortest_bfs_paths(start, target))